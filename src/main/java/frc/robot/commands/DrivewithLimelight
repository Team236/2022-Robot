// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

package frc.robot.commands;


import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;
import edu.wpi.first.networktables.NetworkTableValue;
import edu.wpi.first.wpilibj.Joystick;
import edu.wpi.first.wpilibj2.command.CommandBase;
import frc.robot.subsystems.Drive;
import edu.wpi.first.networktables.NetworkTable;
import edu.wpi.first.networktables.NetworkTableEntry;
import edu.wpi.first.networktables.NetworkTableInstance;



//Kp is a variable that deterimines the coefficent of force we would need to use to cause the robot to swivel. 
public class DriveWithLimeLight extends CommandBase {
private boolean m_LimelightHasValidTarget = false;
private double m_LimelightDriveCommand = 0.0;
private double m_LimelightSteerCommand = 0.0;
private double Kp = 0.03;
private double Ks = 0.02;
private Drive drive;
private double defaultValue = 999;
private double h1 = 14;
private double h2 = 105.6;
private double angle1 = 40;

  /** Creates a new DrivewithLimelight. **/
  public void drivewithLimelight(Drive drive) {

    this.drive = drive;
    // Use addRequirements() here to declare subsystem dependencies.
    addRequirements(this.drive);
  }

  // Called when the command is initially scheduled.
  @Override
  public void initialize() {
  }
  // Called every time the scheduler runs while the command is scheduled.
  @Override 
  public void execute() {
  //aims with limelight 
    NetworkTable table = NetworkTableInstance.getDefault().getTable("limelght");
    double tv = NetworkTableInstance.getDefault().getTable("limelight").getEntry("tv").getDouble(0);
    if (tv < 1.0)
    {
      m_LimelightHasValidTarget = false;
      return;
    }
    m_LimelightHasValidTarget = true;

    
    //max tx = -+ 27 degrees
    //max ty = -+ 20.5 degrees
      Double errorX = table.getEntry("tx").getDouble(defaultValue);
      double x = (errorX-170)/340;
      Double steeringAdjust = Kp * x;
        drive.setLeftSpeed(steeringAdjust);
        drive.setRightSpeed(-steeringAdjust);
      // double angle2 = angle1 - (h2-h1)  ;
      // double dx = (h2-h1)/Math.tan(angle1+angle2);
      // double shootingspeed = Ks * dx;
        //shooter.setspeed(shootingspeed)
        
      //
      }
      //here I intend to use the steering adjust to 
      // if (Errorx < .5) {
      //   pipelineEntry.setNumber(2);
      // }
      // if (Error < .2) {
      //   pipelineEntry.setNumber(3);
      // }
      
      
  
  // Called once the command ends or is interrupted.
  @Override
  public void end(boolean interrupted) {
    drive.stop();
  }

  // Returns true when the command should end.
  @Override
  public boolean isFinished() {
    return false;
  }
}
